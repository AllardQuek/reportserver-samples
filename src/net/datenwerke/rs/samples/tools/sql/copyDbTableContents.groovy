import net.datenwerke.rs.terminal.service.terminal.TerminalSession
import net.datenwerke.dbpool.DbPoolService
import groovy.time.TimeCategory
import groovy.time.TimeDuration
import java.util.logging.Level
import java.util.logging.Logger
import groovy.sql.Sql
import groovy.sql.InParameter

/**
 * copyDbTableContents.groovy
 * Version: 1.0.2
 * Type: Normal Script
 * Last tested with: ReportServer 4.0.0-6053
 * Allows you to copy all contents of a given db-table into another db-table.
 * Note that the tables does not have to reside in the same database, they
 * may reside in different database types. 
 * For example, you can copy contents of table A into table B, where A
 * resides in MSSQL and B in Oracle.
 * The only requirements are:
 * 1. both tables have to exist
 * 2. the fields in both tables must have the same names (and analogous types)
 * 3. datasources of both must be defined in your ReportServer installation
 */

// ==================================================================================
// the datasource containing the source table
sourceDatasourceId = 123L
// the name of the source table
sourceTable = 'mySourceTable'

// the datasource containing the destination table
destinationDatasourceId = 456L
// the destination table
destinationTable = 'myDestinationTable'

// list of the primary keys (of the source table)
primaryKeys = [
   'id'
   ]

/* 
 * true if the script should copy primary keys, else false.
 * Primary auto-increment keys (of the destination table) should not be copied,
 * because these are generated by the db. So in this case you should set this to false.
 */
copyPrimaryKeys = false

// the size of the batch for the batch-insert
batchSize = 100

// ==================================================================================

Date start = new Date()
primaryKeys = primaryKeys*.toUpperCase()
allColNames = []
allColDataTypes = []
insertStmt = ""
primaryKeyIndexes = []
logger = Logger.getLogger(getClass().name)

def session = GLOBALS.getInstance(TerminalSession)
def objectResolver = session.objectResolver
def dbPoolService = GLOBALS.getInstance(DbPoolService)

def sourceDatasource = objectResolver.getObjects("id:DatabaseDatasource:$sourceDatasourceId")
def destinationDatasource = objectResolver.getObjects("id:DatabaseDatasource:$destinationDatasourceId")

assert sourceDatasource && destinationDatasource

dbPoolService.getConnection(sourceDatasource.connectionConfig).get().withCloseable { sourceConn ->
   dbPoolService.getConnection(destinationDatasource.connectionConfig).get().withCloseable { destinationConn ->
      assert sourceConn && destinationConn

      sourceSql = new Sql(sourceConn)
      destinationSql = new Sql(destinationConn)

      collectMeta(sourceConn.metaData.getColumns(null, null, sourceTable, null))

      def selectStmt = "SELECT " + allColNames.join(',') + " FROM " + sourceTable

      printDebugInfo(selectStmt)

      destinationSql.withTransaction {
         destinationSql.withBatch(batchSize, insertStmt as String) { stmt ->
            sourceSql.eachRow(selectStmt) { row -> insertRow(row, stmt) }
         }
      }
   }
}

Date stop = new Date()
TimeDuration td = TimeCategory.minus( stop, start )
tout.println "Completed. Total duration: $td"
logger.log Level.INFO, "Completed. Total duration: $td"


def collectMeta(metaResultSet) {
   readColInfo(metaResultSet)
   allColNames = allColNames*.toUpperCase()

   assert allColNames.containsAll(primaryKeys)

   def insertingColNames = allColNames
   if (!copyPrimaryKeys) {
      insertingColNames = allColNames.withIndex().findAll {
         element, index -> !primaryKeyIndexes.any{ index == it }
      }.collect{ element -> element[0] }
   }

   def placeHolders = insertingColNames.collect{'?'}

   insertStmt = "INSERT INTO $destinationTable (${insertingColNames.join(',')}) "
      << "values (${placeHolders.join(',')})"
}

def insertRow(row, stmt) {
   def vals = row.toRowResult().values() as List

   def withTypes = vals.indexed().collect { idx, v ->
      [
         getType: { -> allColDataTypes[idx] as int},
         getValue: { -> v}
      ] as InParameter
   }
   
   if (!copyPrimaryKeys)  {
      withTypes = withTypes.withIndex().findAll {
         element, index -> !primaryKeyIndexes.any{ index == it }
      }.collect{ element -> element[0] }
   }
   
//   println "types: ${withTypes.collect{ it.getType().toString() } }"

//   logger.log Level.FINE, "Inserting values: $vals"
   stmt.addBatch withTypes
}

def readColInfo(metaResultSet) {
   def cols = []
   def counter = 0
   while (metaResultSet.next()) {
      def columnName = metaResultSet.getString('COLUMN_NAME').toUpperCase()
      def idx = primaryKeys.findIndexOf{ f -> f == columnName }
      if (-1 != idx) {
         //primary key found
         primaryKeyIndexes << counter
      }
      cols << columnName
      
      //col type
      def dataType = metaResultSet.getString('DATA_TYPE')
      allColDataTypes << dataType
      
      counter++
   }
   assert primaryKeyIndexes.size() == primaryKeys.size()
   allColNames = cols
}

def printDebugInfo(selectStmt) {
   tout.println "All colums: $allColNames"
   tout.println  "Datatypes: $allColDataTypes"
   tout.println "Indexes of primary keys: $primaryKeyIndexes"
   tout.println "SELECT statement: $selectStmt"
   tout.println "INSERT statement: $insertStmt"
   
   logger.log Level.INFO, "All colums: $allColNames"
   logger.log Level.INFO, "Indexes of primary keys: $primaryKeyIndexes"
   logger.log Level.INFO, "SELECT statement: $selectStmt"
   logger.log Level.INFO, "INSERT statement: $insertStmt"
}